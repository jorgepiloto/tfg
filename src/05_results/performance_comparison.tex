\section{Performance comparison}
\label{sec:performance}

This section is the core of this work. All the metrics developed and used for
the carrying out the performance comparison are explained in detail together
with the justification on why they were selected.

Previous performance studies made by \cite{klumpp1999}, \cite{torre2015} and in
\cite{martinez2021} were used as the main source of information for this section
and their analysis was improved.

All algorithms have been implemented under the Python programming language and a
library named \citetitle{lamberthub_v01}\footnote{The software can be accessed in
\href{https://github.com/jorgepiloto/lamberthub}{https://github.com/jorgepiloto/lamberthub}.
Latest documentation of the project is hosted in
\href{https://lamberthub.readthedocs.io/en/latest/}{https://lamberthub.readthedocs.io/en/latest/}}
created under a public license, so any author can access it. This software
package ships with all the necessary tools to evaluate the performance of a
solver too and it has been heavily tested again literature cases not only for
the direct transfer problem but also for the multiple revolutions one.

The simulations were performed considering a non-dimensional radius of
$\rho=\norm{\vec{r_2}}/\norm{\vec{r_1}}=2$ and unitary gravitational parameter
$\mu=1$ [L3, T2], where L3 and T2 stand for units of cubic length and squared
time respectively. The problem was solved for a variety of transfer angles
$\Delta \theta$ between $0$ and $2\pi$ and non-dimensional transfer times $\tau$
within the same range of values. For this last parameter, equation
\ref{eq:non_dimensional_tof}:

\begin{equation}
  \tau =  \Delta t \cdot \sqrt{\frac{8\mu}{s^3}}
  \label{eq:non_dimensional_tof}
\end{equation}

By making use of previous equation, each revolution solution lies within an
interval which is a multiple of $2\pi$. For example, the direct transfer problem
will have the solution within the $[0, 2\pi)$ interval, while for the
multiple-revolution scenario, the interval changes to $[2\pi M, 2\pi(M+1))$.

As it has been introduced in several sections, this work only covers the direct
arc transfer, meaning that the multi-revolution scenario is not studied. All
orbits were assumed to be \textit{prograde} and no distinction between
\textit{low} or \textit{short} paths was required as multiple solutions only
appear in the multi-revolution problem. The absolute tolerance was set to $1e-5$
and the relative one to $1e-7$.

The three metrics used in this report are:

\begin{itemize}
  \item \textbf{Number of iterations}: this metric provides information about
        the convergence of the numerical method but also about the initial
        guess. Because the initial guess outputs an estimate solution, the
        accurate this routine is, the lower the amount of iterations required
        by the numerical method.
  \item \textbf{Time per iteration}: which measures the mean time required for
        computing a new approximate value of the free-parameter. This metric
        reveals more information about the time consumed by the numerical
        method.
  \item \textbf{Total computation time}: which computes the total time required
	by the algorithm when computing the solution to the problem. When
	comparing this value to the time employed for the iteration workload, it
	is possible to identify bottlenecks and weak implementation points.
\end{itemize}

Finally, the computer used to perform all the different computations hold the
following specifications: Thinkpad X230 Intel Core i5-3320M CPU at 2.60G
EndevourOS.

\subsection{Number of iterations}

The first metric used for the performance comparison is the amount of iterations
it takes for a solver to achieve the solution for a given combination of $\Delta
  \theta$ and $\Delta \tau$. Black regions show for which points the algorithm did
not converged, either because of the accuracy or the method itself.

Gauss' solver, in figure \ref{fig:iter_gauss}, reveals that the method is only
valid for lower transfer angle and non-dimensional times. This situation was
already known and claimed by several authors in literature. On the other hand,
the improved version of the method by Battin, see \ref{fig:iter_battin}
converges for any case and the imposed absolute tolerance. These last method is
seen to be more robust and accurate than Gauss one.

The solver devised by Gooding shows an stable behavior for most of the solution
space, only requiring between two and three iterations, \ref{fig:iter_gooding}.
This is due to the strong initial guess together with the usage of Halley's
method.

Regarding Avanzini's solver, this algorithm exhibits a lower number of
iterations for transfer angles of the same value of the non-dimensional time of
flight. For corner cases, see \ref{fig:iter_avanzini}, the iterations increase up
to eight or nine. Even with that, the solution is found in all of the cases,
meaning that the algorithm converged without any problem.

Arora's algorithm, in figure \ref{fig:iter_arora}, is seen to be the most stable
one, requiring a mean of only two iterations. This algorithm holds the most
complex initial guess procedure of all the solvers presented in this work, which
together with Halley's method explains the lower amount of iterations.
Convergence is ensured with this solver.

Vallado's solver also converged to the majority of the cases, except for those
ones with low time of flight. However, due to the bisection method employed, the
number of iterations increases dramatically. This can be seen in figure
\ref{fig:iter_vallado}.

Finally, Izzo's solver in figure \ref{fig:iter_izzo} is also seen to be stable
and robust for the majority of the cases. Only values around $\tau=\pi/2$
require more than two iterations, no matter the transfer angle.


% --- START: NUMBER OF ITERATIONS FIGURES ---
\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/iter/iter_gauss_1809.png}
    \caption{Gauss' iterations.}\label{fig:iter_gauss}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/iter/iter_battin_1984.png}
    \caption{Battin's iterations.}\label{fig:iter_battin}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/iter/iter_gooding_1990.png}
    \caption{Gooding' iterations.}\label{fig:iter_gooding}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/iter/iter_avanzini_2008.png}
    \caption{Avanzini's iterations.}\label{fig:iter_avanzini}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/iter/iter_arora_2013.png}
    \caption{Arora' iterations.}\label{fig:iter_arora}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/iter/iter_vallado_2013.png}
    \caption{Vallado's iterations.}\label{fig:iter_vallado}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/iter/iter_izzo_2015.png}
    \caption{Izzo's iterations.}\label{fig:iter_izzo}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/void_figure.png}
  \end{minipage}
\end{figure}
% --- END: NUMBER OF ITERATIONS FIGURES ---

\subsection{Time per iteration}

A solver may require a huge number of may require a huge number of iterations.
However, if each one of those only needs a minimum amount of time, the overall
computation might be a high performance one. In this subsection, the time per
iteration of each one of the solvers is presented.

It is important to state that the time required for a computer to solve a
particular problem might slightly vary due to internal processes which have
nothing to do with the computation process itself. Therefore, the problem was
solved multiple times and the mean iteration time. Let us now present the
results.

For the case of Gauss' solver, the time consumed per iteration is stable as
depicted by figure \ref{fig:tpi_gauss}. On the other hand, Battin's solver in
figure \ref{fig:tpi_battin} shows a reduction in the time per iteration for low
values of the canonical transfer time. However, this last solver requires more
time than Gauss one due to the complexity of the method used. Nevertheless, it
converges for all cases, which is a major advantage over speed as a solution is
found.

Gooding's solver in \ref{fig:tpi_gooding} only shows an critical region near
non-dimensional times of $\tau=\pi/2$. For the rest of the cases, the time per
iteration is quite low and stable. Halley's method is proof to be fast when
carrying out the iteration workload.

The algorithm requiring the greatest amount of time per iteration is Avanzini's
one, see figure \ref{fig:tpi_avanzini}. This solver requires more time for the
regions in which it employed less iterations.

Arora's solver, on the other hand, shows an overall time per iteration slightly
greater than Gooding's one. Even with that, the solver only experiences an
increase in the computation of the time per iteration for values below of
$\tau=\pi/2$. The diagram for this solver is shown in figure
\ref{fig:tpi_arora}.

Vallado's solver, in figure \ref{fig:tpi_vallado} shows now a closer behavior
to the rest of the solvers when discussing the time per iteration. This is due
to the bisection method employed by the solver, as this root solver is fast from
the time per iteration point of view but requires a huge amount of iterations
for achieving the desired absolute tolerance.

The last of the solvers, Izzo's one in figure \ref{fig:tpi_izzo} is not as
stable as Gooding's or Arora's algorithms, but also shows a great stability and
performance for the iteration workload. As similar to Arora's, this solver
experiences and increase in the time per iteration for values of $\tau=\pi/2$.


% --- START: NUMBER OF TIME PER ITERATION FIGURES ---
\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/tpi/tpi_gauss_1809.png}
    \caption{Gauss' time per iteration.}\label{fig:tpi_gauss}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/tpi/tpi_battin_1984.png}
    \caption{Battin's time per iteration.}\label{fig:tpi_battin}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/tpi/tpi_gooding_1990.png}
    \caption{Gooding' time per iteration.}\label{fig:tpi_gooding}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/tpi/tpi_avanzini_2008.png}
    \caption{Avanzini's time per iteration.}\label{fig:tpi_avanzini}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/tpi/tpi_arora_2013.png}
    \caption{Arora' time per iteration.}\label{fig:tpi_arora}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/tpi/tpi_vallado_2013.png}
    \caption{Vallado's time per iteration.}\label{fig:tpi_vallado}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/tpi/tpi_izzo_2015.png}
    \caption{Izzo's time per iteration.}\label{fig:tpi_izzo}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/void_figure.png}
  \end{minipage}
\end{figure}
% --- END: TIME PER ITERATION FIGURES ---


\subsection{Total computation time}

Finally, the total computation time employed by the algorithm for computing the
whole problem is presented. Because the amount of iterations required and the
time per iterations are known, it is possible to compute the percentage of the
time spent during the iteration workload. The idea is that the main workload of
a solver should be located within the iteration process itself and not in the
initial guess computation, the construction of the velocity vectors or function
calls. Again, it must be pointed out that background processes running on local
machine can affect the computation time. 

Gauss' solver exhibits a high total computation time, see figure
\ref{fig:ttc_gauss} even if its time per iteration is low. This means that the
algorithm requires lots of iterations to reach an accurate solution. The
improved version devised by Battin performs much better, as depicted in figure
\ref{fig:ttc_battin}. However, these two algorithms are far from being fast when
computing the solution.

Gooding's solver performs much better in total time than Gauss or Battin
algorithms. The figure in \ref{fig:ttc_gooding} is proportional to previous
results for the number of iterations and time per each one of those. In
addition, a bottlenecks is identified for transfer times near $\tau=\pi/2$.

On the other hand, Avanzini's solver has a huge time cost as seen in figure
\ref{fig:ttc_avanzini}. When comparing this result with previous figures in
\ref{fig:iter_avanzini} and \ref{fig:tpi_avanzini}, an implementation issue
might be the reason behind this. Because the Kepler's equation becomes complex
when written as function of the transverse eccentricity, a simplification making
use of function calls was made. The excessive calls to these function are
probably the reason behind this total computation time results. The usage of a
high-order method might be also a good strategy for reducing the computation time.

Arora's solver presents a very low computation time when compared to the rest of
the solvers. Not only that, a uniform value is found for every combination of
the transfer angle and the canonical time of flight, being not possible to
identify any bottlenecks on figure \ref{fig:ttc_arora}.

Vallado's algorithm, due to bisection method again, is seen to be detrimental
for this algorithm, see the results in figure \ref{fig:ttc_vallado}. However, as
pointed by its author, it converges to the majority of the cases. A possible way
to improve this algorithm would be the introduction of a better initial guess or
mixed numerical solver.

Finally, Izzo's algorithm is the one requiring the lowest amount of time to
converge to the solution. The corner case for this solver was previously
identified during the number of iterations but no effect is seen in figure
\ref{fig:ttc_izzo}.

% --- START: NUMBER OF TOTAL TIME COMPUTATION FIGURES ---
\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/ttc/ttc_gauss_1809.png}
    \caption{Gauss' total computation time.}\label{fig:ttc_gauss}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/ttc/ttc_battin_1984.png}
    \caption{Battin's total computation time.}\label{fig:ttc_battin}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/ttc/ttc_gooding_1990.png}
    \caption{Gooding' total computation time.}\label{fig:ttc_gooding}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/ttc/ttc_avanzini_2008.png}
    \caption{Avanzini's total computation time.}\label{fig:ttc_avanzini}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/ttc/ttc_arora_2013.png}
    \caption{Arora' total computation time.}\label{fig:ttc_arora}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/ttc/ttc_vallado_2013.png}
    \caption{Vallado's total computation time.}\label{fig:ttc_vallado}
  \end{minipage}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/ttc/ttc_izzo_2015.png}
    \caption{Izzo's total computation time.}\label{fig:ttc_izzo}
  \end{minipage}\hfill
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=1.05\linewidth]{static/void_figure.png}
  \end{minipage}
\end{figure}
% --- END: TOTAL TIME COMPUTATION ITERATION FIGURES ---
