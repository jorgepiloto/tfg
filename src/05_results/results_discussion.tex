\section{Discussion of the results}

In table \ref{table:resume_performance}, the fundamental performance data has
been collected so reader can better study it. All the metrics are shown,
including the mean number of iterations, the time per each one of those, the
total computation time and finally the iteration workload. This last parameter
has been computed considering expression \ref{eq:iter_workload}:

\begin{equation}
  \text{Iteration workload} = \frac{\text{Mean number of iterations} \times \text{Time per iteration}}{\text{Total computation time}}
  \label{eq:iter_workload}
\end{equation}

being the result expressed as a percentage.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\multirow{2}{*}{\textbf{Method}} & \multicolumn{4}{c|}{\textbf{Performance data}}         \\ \cline{2-5}
 &
  \textbf{\begin{tabular}[c]{@{}c@{}}Mean \\ iterations\end{tabular}} &
  \textbf{\begin{tabular}[c]{@{}c@{}}Time \\ per iteration\end{tabular}} &
  \textbf{\begin{tabular}[c]{@{}c@{}}Total\\ computation time\end{tabular}} &
  \textbf{\begin{tabular}[c]{@{}c@{}}Iteration\\ workload\end{tabular}} \\ \hline
Gauss 1809                       & 10.96 & 652.24 $\mu$s/iter & 8752.05 $\mu$s & 81.68 \% \\ \hline
Battin 1984                      & 3.82  & 96.34 $\mu$s/iter  & 769.49 $\mu$s  & 47.83 \% \\ \hline
Gooding 1990                     & 2.67  & 27.92 $\mu$s/iter  & 771.92 $\mu$s  & 9.66 \%  \\ \hline
Avanzini 2008                    & 4.65  & 168.64 $\mu$s/iter & 2735.59 $\mu$s & 28.67 \% \\ \hline
Arora 2013                       & 2.14  & 41.94 $\mu$s/iter  & 570.63 $\mu$s  & 15.73 \% \\ \hline
Vallado 2013                     & 24.32 & 54.31 $\mu$s/iter  & 1632.27 $\mu$s & 80.92 \% \\ \hline
Izzo 2015                        & 2.33  & 47.51 $\mu$s/iter  & 444.62 $\mu$s  & 24.90 \% \\ \hline
\end{tabular}
\caption{Critical performance data for each solver.}
\label{table:resume_performance}
\end{table}

The iteration workload indicates how much of the total computation time is
consumed by a solver when performing the iterative process. One might think that
a high iteration workload is desired, which indicates that the root solver
performs the majority of the work. However, this may also mean that the
initial guess is poor, so an excessive amount of iterations are being performed.

For the case of \cite{gauss1809}, this algorithm shows the greatest iteration
workload meaning that its focuses on the computation of the independent
variable. However, this algorithm is known not to converge for the majority of
the cases and shows an excessive amount of total computation time.

Regarding \cite{battin1984}, around half of the time is devoted to the
computation of the free-parameter. The solver also has a lower computation time
if compared to Gauss one. Therefore, the method devised by Battin and Vaughan
truly improves the one by Gauss.

\cite{gooding1990} solver has a similar total computation time as Battin's
algorithm. However, the iteration workload is seen to be the lowest one, showing
up that the majority of the time is being consumed by the initial guess.
Nevertheless, Gooding's solver converges with great accuracy to the final
solution.

On the other hand, the relation between iteration workload and computation time
for \cite{avanzini2008} is poor. This algorithm lacks of an extensive initial
guess but requires lots of function calls to have the Kepler's equation as
direct function of the free-parameter. These function calls are shown to produce
a bottleneck in the performance of this solver. The use of a high-order
numerical method would probably reduce the amount of required iterations.

\cite{arora2013} shows the lowest computation time per iteration and the
iteration workload shows a low value due to the short amount of iterations
required by the solver.  Arora's solver employed an exhaustive initial guess,
devoting the majority of the time to this procedure. Neverhteless, the solver is
seen to have a high performance, knowing that it converges for all cases and
includes the multi-revolution scenario. 

\cite{izzo2015} has the lowest computation time while showing a
relatively high iteration workload. The arbitrary initial guess based on a
linear approximation in combination with Householder's method makes this a high
performance solver who's implementation improves the one devised by Gooding's one.

Finally, for sorting of the solvers from a performance point of view, the
following criteria has been established by order of priority:

\begin{enumerate}
  \item Convergence of a solver: the greater of the covered cases, the better.
  \item Total computation time: the lower, the better.
  \item Iteration workload: the greater, the better.
\end{enumerate}

which leads to the following performance ranking: \cite{izzo2015},
\cite{arora2013}, \cite{gooding1990}, \cite{battin1984}, \cite{avanzini2008},
\cite{vallado2013}, \cite{gauss1809}.

A key concept arose from the performance comparison. A strong initial guess
is critical for reducing the number of iterations but if too complex, the total
computation time will increase. The idea is to have a simple initial guess
routine so the whole iteration workload can be performed by the root solver.
From the results presented in this work, high-order root solvers are preferred,
although those ones based on Bolzano's theorem might be used for critical
regions in the time of flight curves.
